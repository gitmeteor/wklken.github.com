<!DOCTYPE html>
<html lang="en">

<!--[if IE 8]> <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->

<head>
    <meta name="google-site-verification" content="SzE6WCs23qFevgBzRIuG9vcfLU0lW_Vd5hFT-cJOLBE" />
    <title>Python 源码阅读 - 垃圾回收机制</title>
    <meta charset="utf-8" />
    <meta name="description" content="">
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <link rel="shortcut icon" href="/favicon.ico"/>
        <link rel="stylesheet" href="/theme/css/styles.css" media="all" />
        <link rel="stylesheet" href="/theme/css/monokai.css" media="all" />
        <link rel="stylesheet" href="/theme/css/tab.min.css" media="all" />
        <link rel="stylesheet" href="/theme/css/jquery-ui.min.css" media="all" />

        <link rel="stylesheet" href="/theme/css/font-awesome.min.css">
        <!--
        <link rel="stylesheet" href="http://apps.bdimg.com/libs/fontawesome/4.2.0/css/font-awesome.min.css">
        -->
        <!--[if IE 7]>
            <link rel="stylesheet" href="/theme/css/font-awesome-ie7.min.css">
        <![endif]-->

        <link href="/" type="application/atom+xml" rel="alternate" title="wklken's blog ATOM Feed" />
        <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="wklken's blog RSS Feed" />

</head>

<body>
    <div id="page" class="row">
        <div class="large-9 large-centered columns">

        <header id="header">
            <div class="constraint">
                <div class="o">
                    <a href="/"><h1 class="banner">Wklken <span class="blue"> Building </span></h1></a>

                <div class="social">
                            <a href="https://github.com/wklken" target='_blank'><i class="icon-github-sign icon-2x"></i></a>
                            <a href="http://weibo.com/wklken" target='_blank'><i class="icon-weibo icon-2x"></i></a>
                            <a href="mailto:wklken@yeah.net"><i class="icon-envelope icon-2x"></i></a>
                            <a href="http://www.wklken.me/feed.xml" target='_blank'><i class="icon-rss-sign icon-2x"></i></a>
                </div>
                <div class="nav">
                            <a href="/">首页</a>
                            <a href="/categories.html">分类</a>
                            <a href="/archives.html">归档</a>
                            <a href="/pages/projects.html">项目</a>
                            <a href="/pages/links.html">友链</a>
                            <a href="/pages/aboutme.html">关于</a>

                </div>

                </div>
            </div>
        </header><!-- /#banner -->

        <section id="main">


<article id="article">
    <section id="header">
        <!--
        <div class="meta">2015年09月29日</div>
        <h1 id="title"> Python 源码阅读 - 垃圾回收机制 </h1>
        -->
        <div class="meta"> &nbsp; </div>
        <h1> Python 源码阅读 - 垃圾回收机制 </h1>
    </section>

        <section id="toc">
            <div id="toc"><ul><li><a class="toc-href" href="#" title="Python 源码阅读 - 垃圾回收机制">Python 源码阅读 - 垃圾回收机制</a><ul><li><a class="toc-href" href="#gai-shu" title="概述">概述</a></li><li><a class="toc-href" href="#yin-yong-ji-shu" title="引用计数">引用计数</a><ul><li><a class="toc-href" href="#ji-shu-cun-chu" title="计数存储">计数存储</a></li><li><a class="toc-href" href="#ji-shu-zeng-jia" title="计数增加">计数增加</a></li></ul></li><li><a class="toc-href" href="#define-py_increfop_2" title="define Py_INCREF(op) (                         \">define Py_INCREF(op) (                         \</a><ul><li><a class="toc-href" href="#ji-shu-jian-shao" title="计数减少">计数减少</a></li></ul></li><li><a class="toc-href" href="#define-_py_dec_reftotal-_py_reftotal-_1" title="define _Py_DEC_REFTOTAL        _Py_RefTotal--">define _Py_DEC_REFTOTAL        _Py_RefTotal--</a></li><li><a class="toc-href" href="#define-_py_ref_debug_comma" title="define _Py_REF_DEBUG_COMMA     ,">define _Py_REF_DEBUG_COMMA     ,</a></li><li><a class="toc-href" href="#define-py_decrefop" title="define Py_DECREF(op)                                   \">define Py_DECREF(op)                                   \</a></li><li><a class="toc-href" href="#define-_py_ref_debug_comma_1" title="define _Py_REF_DEBUG_COMMA     ,">define _Py_REF_DEBUG_COMMA     ,</a></li><li><a class="toc-href" href="#define-_py_deallocop" title="define _Py_Dealloc(op) (                               \">define _Py_Dealloc(op) (                               \</a></li><li><a class="toc-href" href="#endif-py_trace_refs" title="endif / !Py_TRACE_REFS /">endif / !Py_TRACE_REFS /</a><ul><li><a class="toc-href" href="#nei-cun-hui-shou-pyobject_del-pyobject_gc_del" title="内存回收 PyObject_Del / PyObject_GC_Del">内存回收 PyObject_Del / PyObject_GC_Del</a></li><li><a class="toc-href" href="#biao-ji-qing-chu_1" title="标记-清除">标记-清除</a><ul><li><a class="toc-href" href="#wen-ti-shi-yao-dui-xiang-ke-neng-chan-sheng-xun-huan-yin-yong" title="问题: 什么对象可能产生循环引用?">问题: 什么对象可能产生循环引用?</a></li><li><a class="toc-href" href="#ke-shou-ji-dui-xiang-lian-biao" title="可收集对象链表">可收集对象链表</a></li></ul></li></ul></li><li><a class="toc-href" href="#define-pyobject_head_2" title="define PyObject_HEAD                   \">define PyObject_HEAD                   \</a></li><li><a class="toc-href" href="#define-_pygc_refs_untracked-2" title="define _PyGC_REFS_UNTRACKED                    (-2)">define _PyGC_REFS_UNTRACKED                    (-2)</a></li><li><a class="toc-href" href="#define-gc_untracked-_pygc_refs_untracked" title="define GC_UNTRACKED                    _PyGC_REFS_UNTRACKED">define GC_UNTRACKED                    _PyGC_REFS_UNTRACKED</a><ul><li><a class="toc-href" href="#pyobject_head-and-pygc_head" title="PyObject_HEAD and PyGC_HEAD">PyObject_HEAD and PyGC_HEAD</a></li></ul></li><li><a class="toc-href" href="#define-as_gco-pygc_head-o-1_1" title="define AS_GC(o) ((PyGC_Head *)(o)-1)">define AS_GC(o) ((PyGC_Head *)(o)-1)</a></li><li><a class="toc-href" href="#define-from_gcg-pyobject-pygc_head-g1" title="define FROM_GC(g) ((PyObject )(((PyGC_Head )g)+1))">define FROM_GC(g) ((PyObject )(((PyGC_Head )g)+1))</a></li><li><a class="toc-href" href="#define-_py_as_gco-pygc_head-o-1" title="define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)">define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)</a><ul><li><a class="toc-href" href="#wen-ti-shi-yao-shi-hou-jiang-containerfang-dao-zhe-ge-dui-xiang-lian-biao-zhong" title="问题: 什么时候将container放到这个对象链表中">问题: 什么时候将container放到这个对象链表中</a></li></ul></li><li><a class="toc-href" href="#define-_pyobject_gc_tracko-do_1" title="define _PyObject_GC_TRACK(o) do { \">define _PyObject_GC_TRACK(o) do { \</a><ul><li><a class="toc-href" href="#wen-ti-shi-yao-shi-hou-jiang-containercong-zhe-ge-dui-xiang-lian-biao-zhong-zhai-chu" title="问题: 什么时候将container从这个对象链表中摘除">问题: 什么时候将container从这个对象链表中摘除</a></li></ul></li><li><a class="toc-href" href="#define-_pyobject_gc_untracko-do_1" title="define _PyObject_GC_UNTRACK(o) do { \">define _PyObject_GC_UNTRACK(o) do { \</a><ul><li><a class="toc-href" href="#wen-ti-ru-he-jin-xing-biao-ji-qing-chu" title="问题: 如何进行标记-清除">问题: 如何进行标记-清除</a><ul><li><a class="toc-href" href="#0-gai-lan" title="0. 概览">0. 概览</a></li><li><a class="toc-href" href="#1-di-yi-bu-gc_list_merge" title="1. 第一步:  gc_list_merge">1. 第一步:  gc_list_merge</a></li><li><a class="toc-href" href="#2-di-er-bu-update_refs" title="2. 第二步: update_refs">2. 第二步: update_refs</a></li><li><a class="toc-href" href="#3-di-san-bu-ji-suan-you-xiao-yin-yong-ji-shu" title="3. 第三步: 计算有效引用计数">3. 第三步: 计算有效引用计数</a></li><li><a class="toc-href" href="#4-di-si-bu-la-ji-biao-ji" title="4. 第四步: 垃圾标记">4. 第四步: 垃圾标记</a></li><li><a class="toc-href" href="#5-di-wu-bu-jiang-cun-huo-dui-xiang-fang-ru-xia-yi-dai" title="5. 第五步: 将存活对象放入下一代">5. 第五步: 将存活对象放入下一代</a></li><li><a class="toc-href" href="#6-di-liu-bu-zhi-xing-hui-shou" title="6. 第六步: 执行回收">6. 第六步: 执行回收</a></li><li><a class="toc-href" href="#7-gcluo-ji" title="7. gc逻辑">7. gc逻辑</a></li></ul></li><li><a class="toc-href" href="#fen-dai-hui-shou_2" title="分代回收">分代回收</a><ul><li><a class="toc-href" href="#biao-tou-shu-ju-jie-gou" title="表头数据结构">表头数据结构</a></li><li><a class="toc-href" href="#san-ge-dai-de-ding-yi" title="三个代的定义">三个代的定义</a></li><li><a class="toc-href" href="#chao-guo-yu-zhi-hong-fa-la-ji-hui-shou" title="超过阈值, 触发垃圾回收">超过阈值, 触发垃圾回收</a></li></ul></li><li><a class="toc-href" href="#python-zhong-de-gcmo-kuai_1" title="Python 中的gc模块">Python 中的gc模块</a></li></ul></li></ul></li></ul></div>
        </section>
    <section id="content">
        <h2 id="gai-shu">概述</h2>
<p>无论何种垃圾收集机制, 一般都是两阶段: 垃圾检测和垃圾回收.</p>
<p>在Python中, 大多数对象的生命周期都是通过对象的引用计数来管理的.</p>
<p>问题: 但是存在循环引用的问题: a 引用 b, b 引用 a, 导致每一个对象的引用计数都不为0, 所占用的内存永远不会被回收</p>
<p>要解决循环引用: 必需引入其他垃圾收集技术来打破循环引用. Python中使用了<code>标记-清除</code>以及<code>分代收集</code></p>
<p>即, Python 中垃圾回收机制: 引用计数(主要), 标记清除, 分代收集(辅助)</p>
<h2 id="yin-yong-ji-shu">引用计数</h2>
<p>引用计数, 意味着必须在每次分配和释放内存的时候, 加入管理引用计数的动作</p>
<p>引用计数的优点: 最直观最简单, 实时性, 任何内存, 一旦没有指向它的引用, 就会立即被回收</p>
<h3 id="ji-shu-cun-chu">计数存储</h3>
<p>回顾  <a href="http://www.wklken.me/posts/2014/08/05/python-source-object.html">Python 的对象</a></p>
<p><img alt="" src="http://www.wklken.me/imgs/python-source/PyObject.png"/>￼</p>
<p><img alt="" src="http://www.wklken.me/imgs/python-source/PyVarObject.png"/>￼</p>
<p>e.g. 引用计数增加以及减少</p>
<p>```python</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sys import getrefcount</p>
<p>a = [1, 2, 3]
getrefcount(a)
2
b = a
getrefcount(a)
3
del b
getrefcount(a)
2
```</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="ji-shu-zeng-jia">计数增加</h3>
<p>增加对象引用计数, refcnt incr</p>
<p>```c</p>
<h1 id="define-py_increfop_2">define Py_INCREF(op) (                         \</h1>
<div class="monokai"><pre><span></span>_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \
((PyObject*)(op))-&gt;ob_refcnt++)
</pre></div>
<p>```</p>
<h3 id="ji-shu-jian-shao">计数减少</h3>
<p>减少对象引用计数, refcnt desc</p>
<p>```c</p>
<h1 id="define-_py_dec_reftotal-_py_reftotal-_1">define _Py_DEC_REFTOTAL        _Py_RefTotal--</h1>
<h1 id="define-_py_ref_debug_comma">define _Py_REF_DEBUG_COMMA     ,</h1>
<h1 id="define-py_decrefop">define Py_DECREF(op)                                   \</h1>
<div class="monokai"><pre><span></span>do {                                                \
    if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \
    --((PyObject*)(op))-&gt;ob_refcnt != 0)            \
        _Py_CHECK_REFCNT(op)                        \
    else                                            \
    _Py_Dealloc((PyObject *)(op));                  \
} while (0)
</pre></div>
<p>```</p>
<p>即, 发现refcnt变成0的时候, 会调用<code>_Py_Dealloc</code></p>
<p>```c
PyAPI_FUNC(void) _Py_Dealloc(PyObject *);</p>
<h1 id="define-_py_ref_debug_comma_1">define _Py_REF_DEBUG_COMMA     ,</h1>
<h1 id="define-_py_deallocop">define _Py_Dealloc(op) (                               \</h1>
<div class="monokai"><pre><span></span>_Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \
(*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))
</pre></div>
<h1 id="endif-py_trace_refs">endif /<em> !Py_TRACE_REFS </em>/</h1>
<p>```</p>
<p>会调用各自类型的<code>tp_dealloc</code></p>
<p>例如dict</p>
<p>```c
PyTypeObject PyDict_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "dict",
    sizeof(PyDictObject),
    0,
    (destructor)dict_dealloc,                   /<em> tp_dealloc </em>/
    ....
}</p>
<p>static void
dict_dealloc(register PyDictObject <em>mp)
{
    .....
    // 如果满足条件, 放入到缓冲池freelist中
    if (numfree &lt; PyDict_MAXFREELIST &amp;&amp; Py_TYPE(mp) == &amp;PyDict_Type)
        free_list[numfree++] = mp;
    // 否则, 调用tp_free
    else
        Py_TYPE(mp)-&gt;tp_free((PyObject </em>)mp);
    Py_TRASHCAN_SAFE_END(mp)
}
```</p>
<p>Python基本类型的<code>tp_dealloc</code>, 通常都会与各自的缓冲池机制相关, 释放会优先放入缓冲池中(对应的分配会优先从缓冲池取). 这个内存分配与回收同缓冲池机制相关</p>
<p>当无法放入缓冲池时, 会调用各自类型的<code>tp_free</code></p>
<p>int, 比较特殊</p>
<p><code>c
// int, 通用整数对象缓冲池机制
      (freefunc)int_free,                         /* tp_free */</code></p>
<p>string</p>
<p><code>c
// string
    PyObject_Del,                               /* tp_free */</code></p>
<p>dict/tuple/list</p>
<p><code>c
    PyObject_GC_Del,                            /* tp_free */</code></p>
<p>然后, 我们再回头看, 自定义对象的<code>tp_free</code></p>
<p><code>c
PyTypeObject PyType_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "type",                                     /* tp_name */
    ...
    PyObject_GC_Del,                            /* tp_free */
};</code></p>
<p>即, 最终, 当计数变为0, 触发内存回收动作. 涉及函数<code>PyObject_Del</code>和<code>PyObject_GC_Del</code>, 并且, 自定义类以及容器类型(dict/list/tuple/set等)使用的都是后者<code>PyObject_GC_Del</code>.</p>
<h3 id="nei-cun-hui-shou-pyobject_del-pyobject_gc_del">内存回收 PyObject_Del / PyObject_GC_Del</h3>
<p>如果引用计数=0:</p>
<p><code>plain
1. 放入缓冲池
2. 真正销毁, PyObject_Del/PyObject_GC_Del内存操作</code></p>
<p>这两个操作都是进行内存级别的操作</p>
<ul>
<li>PyObject_Del</li>
</ul>
<blockquote>
<p>PyObject_Del(op) releases the memory allocated for an object.  It does not
  run a destructor -- it only frees the memory.  PyObject_Free is identical.</p>
</blockquote>
<p>这块删除, <code>PyObject_Free</code> 涉及到了Python底层内存的分配和管理机制, 具体见前面的博文</p>
<ul>
<li>PyObject_GC_Del</li>
</ul>
<p>```c
void
PyObject_GC_Del(void <em>op)
{
    PyGC_Head </em>g = AS_GC(op);</p>
<div class="monokai"><pre><span></span>// Returns true if a given object is tracked
if (IS_TRACKED(op))
    // 从跟踪链表中移除
    gc_list_remove(g);
if (generations[0].count &gt; 0) {
    generations[0].count--;
}
PyObject_FREE(g);
</pre></div>
<p>}
```</p>
<p><code>IS_TRACKED</code> 涉及到标记-清除的机制</p>
<p><code>generations</code> 涉及到了分代回收</p>
<p><code>PyObject_FREE</code>, 则和Python底层内存池机制相关</p>
<h2 id="biao-ji-qing-chu_1">标记-清除</h2>
<h3 id="wen-ti-shi-yao-dui-xiang-ke-neng-chan-sheng-xun-huan-yin-yong">问题: 什么对象可能产生循环引用?</h3>
<p>只需要关注关注可能产生循环引用的对象</p>
<p>PyIntObject/PyStringObject等不可能</p>
<p>Python中的循环引用总是发生在container对象之间, 所谓containser对象即是内部可持有对其他对象的引用: list/dict/class/instance等等</p>
<p>垃圾收集带来的开销依赖于container对象的数量, 必需跟踪所创建的每一个container对象, 并将这些对象组织到一个集合中.</p>
<h3 id="ke-shou-ji-dui-xiang-lian-biao">可收集对象链表</h3>
<p>可收集对象链表: 将需要被收集和跟踪的container, 放到可收集的链表中</p>
<p>任何一个python对象都分为两部分: PyObject_HEAD + 对象本身数据</p>
<p>```c
/<em> PyObject_HEAD defines the initial segment of every PyObject. </em>/</p>
<h1 id="define-pyobject_head_2">define PyObject_HEAD                   \</h1>
<div class="monokai"><pre><span></span>_PyObject_HEAD_EXTRA                \
Py_ssize_t ob_refcnt;               \
struct _typeobject *ob_type;
</pre></div>
<p>//----------------------------------------------------</p>
<p>#define _PyObject_HEAD_EXTRA            \
      struct _object <em>_ob_next;           \
      struct _object </em>_ob_prev;</p>
<p>// 双向链表结构, 垃圾回收
```</p>
<p>可收集对象链表</p>
<p>```c
Modules/gcmodule.c</p>
<p>/<em> GC information is stored BEFORE the object structure. </em>/
typedef union _gc_head {
    struct {
        // 建立链表需要的前后指针
        union _gc_head <em>gc_next;
        union _gc_head </em>gc_prev;
        // 在初始化时会被初始化为 GC_UNTRACED
        Py_ssize_t gc_refs;
    } gc;
    long double dummy;  /<em> force worst-case alignment </em>/
} PyGC_Head;</p>
<p>```</p>
<p>创建container的过程: <code>container对象 = pyGC_Head | PyObject_HEAD | Container Object</code></p>
<p>```c
PyObject <em>
_PyObject_GC_New(PyTypeObject </em>tp)
{
    PyObject *op = _PyObject_GC_Malloc(_PyObject_SIZE(tp));
    if (op != NULL)
        op = PyObject_INIT(op, tp);
    return op;
}</p>
<p>=&gt; _PyObject_GC_Malloc</p>
<h1 id="define-_pygc_refs_untracked-2">define _PyGC_REFS_UNTRACKED                    (-2)</h1>
<h1 id="define-gc_untracked-_pygc_refs_untracked">define GC_UNTRACKED                    _PyGC_REFS_UNTRACKED</h1>
<p>PyObject <em>
_PyObject_GC_Malloc(size_t basicsize)
{
    PyObject </em>op;
    PyGC_Head *g;
    if (basicsize &gt; PY_SSIZE_T_MAX - sizeof(PyGC_Head))
        return PyErr_NoMemory();</p>
<div class="monokai"><pre><span></span>// 为 对象本身+PyGC_Head申请内存, 注意分配的size
g = (PyGC_Head *)PyObject_MALLOC(
    sizeof(PyGC_Head) + basicsize);
if (g == NULL)
    return PyErr_NoMemory();

// 初始化 GC_UNTRACED
g-&gt;gc.gc_refs = GC_UNTRACKED;
generations[0].count++; /* number of allocated GC objects */

// 如果大于阈值, 执行分代回收
if (generations[0].count &gt; generations[0].threshold &amp;&amp;
    enabled &amp;&amp;
    generations[0].threshold &amp;&amp;
    !collecting &amp;&amp;
    !PyErr_Occurred()) {

    collecting = 1;
    collect_generations();
    collecting = 0;
}
op = FROM_GC(g);
return op;
</pre></div>
<p>}
```</p>
<h3 id="pyobject_head-and-pygc_head">PyObject_HEAD and PyGC_HEAD</h3>
<p>注意, <code>FROM_GC</code>和<code>AS_GC</code>用于 <code>PyObject_HEAD &lt;=&gt; PyGC_HEAD</code>地址相互转换</p>
<p>```c
// =&gt; Modules/gcmodule.c</p>
<p>/<em> Get an object's GC head </em>/</p>
<h1 id="define-as_gco-pygc_head-o-1_1">define AS_GC(o) ((PyGC_Head *)(o)-1)</h1>
<p>/<em> Get the object given the GC head </em>/</p>
<h1 id="define-from_gcg-pyobject-pygc_head-g1">define FROM_GC(g) ((PyObject <em>)(((PyGC_Head </em>)g)+1))</h1>
<p>// =&gt; objimpl.h</p>
<h1 id="define-_py_as_gco-pygc_head-o-1">define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)</h1>
<p>```</p>
<h3 id="wen-ti-shi-yao-shi-hou-jiang-containerfang-dao-zhe-ge-dui-xiang-lian-biao-zhong">问题: 什么时候将container放到这个对象链表中</h3>
<p>e.g list</p>
<p>```c
// =&gt; listobject.c</p>
<p>PyObject <em>
PyList_New(Py_ssize_t size)
{
    PyListObject </em>op;
    op = PyObject_GC_New(PyListObject, &amp;PyList_Type);
    _PyObject_GC_TRACK(op);
    return (PyObject *) op;
}</p>
<p>// =&gt;  _PyObject_GC_TRACK</p>
<p>// objimpl.h
// 加入到可收集对象链表中</p>
<h1 id="define-_pyobject_gc_tracko-do_1">define _PyObject_GC_TRACK(o) do { \</h1>
<div class="monokai"><pre><span></span>PyGC_Head *g = _Py_AS_GC(o); \
if (g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED) \
    Py_FatalError("GC object already tracked"); \
g-&gt;gc.gc_refs = _PyGC_REFS_REACHABLE; \
g-&gt;gc.gc_next = _PyGC_generation0; \
g-&gt;gc.gc_prev = _PyGC_generation0-&gt;gc.gc_prev; \
g-&gt;gc.gc_prev-&gt;gc.gc_next = g; \
_PyGC_generation0-&gt;gc.gc_prev = g; \
} while (0);
</pre></div>
<p>```</p>
<h3 id="wen-ti-shi-yao-shi-hou-jiang-containercong-zhe-ge-dui-xiang-lian-biao-zhong-zhai-chu">问题: 什么时候将container从这个对象链表中摘除</h3>
<p>```c
// Objects/listobject.c</p>
<p>static void
list_dealloc(PyListObject *op)
{
    Py_ssize_t i;
    PyObject_GC_UnTrack(op);
    .....
}</p>
<p>// =&gt; PyObject_GC_UnTrack =&gt; _PyObject_GC_UNTRACK</p>
<p>// 对象销毁的时候</p>
<h1 id="define-_pyobject_gc_untracko-do_1">define _PyObject_GC_UNTRACK(o) do { \</h1>
<div class="monokai"><pre><span></span>PyGC_Head *g = _Py_AS_GC(o); \
assert(g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED); \
g-&gt;gc.gc_refs = _PyGC_REFS_UNTRACKED; \
g-&gt;gc.gc_prev-&gt;gc.gc_next = g-&gt;gc.gc_next; \
g-&gt;gc.gc_next-&gt;gc.gc_prev = g-&gt;gc.gc_prev; \
g-&gt;gc.gc_next = NULL; \
} while (0);
</pre></div>
<p>```</p>
<h3 id="wen-ti-ru-he-jin-xing-biao-ji-qing-chu">问题: 如何进行标记-清除</h3>
<p>现在, 我们得到了一个链表</p>
<p>Python将自己的垃圾收集限制在这个链表上, 循环引用一定发生在这个链表的一群独享之间.</p>
<h4 id="0-gai-lan">0. 概览</h4>
<p><code>_PyObject_GC_Malloc</code> 分配内存时, 发现超过阈值, 此时, 会触发gc, <code>collect_generations</code>
然后调用<code>collect</code>, <code>collect</code>包含标记-清除逻辑</p>
<p>```c
gcmodule.c</p>
<p>/<em> This is the main function.  Read this to understand how the
   * collection process works. </em>/
  static Py_ssize_t
  collect(int generation)
  {
    // 第1步: 将所有比 当前代 年轻的代中的对象 都放到 当前代 的对象链表中
    /<em> merge younger generations with one we are currently collecting </em>/
    for (i = 0; i &lt; generation; i++) {
        gc_list_merge(GEN_HEAD(i), GEN_HEAD(generation));
    }</p>
<div class="monokai"><pre><span></span>// 第2步
update_refs(young);
// 第3步
subtract_refs(young);

// 第4步
gc_list_init(&amp;unreachable);
move_unreachable(young, &amp;unreachable);

// 第5步
  /* Move reachable objects to next generation. */
  if (young != old) {
      if (generation == NUM_GENERATIONS - 2) {
          long_lived_pending += gc_list_size(young);
      }
      gc_list_merge(young, old);
  }
  else {
      /* We only untrack dicts in full collections, to avoid quadratic
         dict build-up. See issue #14775. */
      untrack_dicts(young);
      long_lived_pending = 0;
      long_lived_total = gc_list_size(young);
  }

// 第6步
  delete_garbage(&amp;unreachable, old);
</pre></div>
<p>}</p>
<p>```</p>
<h4 id="1-di-yi-bu-gc_list_merge">1. 第一步:  gc_list_merge</h4>
<p>将所有比 当前代 年轻的代中的对象 都放到 当前代 的对象链表中</p>
<p>```c
// =&gt; gc_list_merge</p>
<p>// 执行拷贝而已
/<em> append list <code>from</code> onto list <code>to</code>; <code>from</code> becomes an empty list </em>/
static void
gc_list_merge(PyGC_Head <em>from, PyGC_Head </em>to)
{
    PyGC_Head *tail;
    assert(from != to);
    if (!gc_list_is_empty(from)) {
        tail = to-&gt;gc.gc_prev;
        tail-&gt;gc.gc_next = from-&gt;gc.gc_next;
        tail-&gt;gc.gc_next-&gt;gc.gc_prev = tail;
        to-&gt;gc.gc_prev = from-&gt;gc.gc_prev;
        to-&gt;gc.gc_prev-&gt;gc.gc_next = to;
    }
    // 清空
    gc_list_init(from);
}</p>
<p>=&gt;</p>
<p>static void
gc_list_init(PyGC_Head *list)
{
    list-&gt;gc.gc_prev = list;
    list-&gt;gc.gc_next = list;
}
```</p>
<p>即, 此刻, 所有待进行处理的对象都集中在同一个链表中</p>
<p>处理,</p>
<p>其逻辑是, 要去除循环引用, 得到有效引用计数</p>
<p>有效引用计数: 将循环引用的计数去除, 最终得到的 =&gt; 将环从引用中摘除, 各自引用计数数值-1</p>
<p>实际操作, 并不要直接修改对象的 ob_refcnt, 而是修改其副本, <code>PyGC_Head</code>中的<code>gc.gc_ref</code></p>
<h4 id="2-di-er-bu-update_refs">2. 第二步: update_refs</h4>
<p>遍历对象链表, 将每个对象的gc.gc_ref值设置为ob_refcnt</p>
<p>```c
// =&gt; gcmodule.c</p>
<p>static void
update_refs(PyGC_Head <em>containers)
{
    PyGC_Head </em>gc = containers-&gt;gc.gc_next;
    for (; gc != containers; gc = gc-&gt;gc.gc_next) {
        assert(gc-&gt;gc.gc_refs == GC_REACHABLE);
        gc-&gt;gc.gc_refs = Py_REFCNT(FROM_GC(gc));
        /<em> Python's cyclic gc should never see an incoming refcount
         * of 0:  if something decref'ed to 0, it should have been
         * deallocated immediately at that time.
         * Possible cause (if the assert triggers):  a tp_dealloc
         * routine left a gc-aware object tracked during its teardown
         * phase, and did something-- or allowed something to happen --
         * that called back into Python.  gc can trigger then, and may
         * see the still-tracked dying object.  Before this assert
         * was added, such mistakes went on to allow gc to try to
         * delete the object again.  In a debug build, that caused
         * a mysterious segfault, when _Py_ForgetReference tried
         * to remove the object from the doubly-linked list of all
         * objects a second time.  In a release build, an actual
         * double deallocation occurred, which leads to corruption
         * of the allocator's internal bookkeeping pointers.  That's
         * so serious that maybe this should be a release-build
         * check instead of an assert?
         </em>/
        assert(gc-&gt;gc.gc_refs != 0);
    }
}
```</p>
<h4 id="3-di-san-bu-ji-suan-you-xiao-yin-yong-ji-shu">3. 第三步: 计算有效引用计数</h4>
<p>```c
  /<em> A traversal callback for subtract_refs. </em>/
  static int
  visit_decref(PyObject <em>op, void </em>data)
  {
      assert(op != NULL);
      // 判断op指向的对象是否是被垃圾收集监控的, 对象的type对象中有Py_TPFLAGS_HAVE_GC符号
      if (PyObject_IS_GC(op)) {
          PyGC_Head <em>gc = AS_GC(op);
          /</em> We're only interested in gc_refs for objects in the
           * generation being collected, which can be recognized
           * because only they have positive gc_refs.
           <em>/
          assert(gc-&gt;gc.gc_refs != 0); /</em> else refcount was too small */
          if (gc-&gt;gc.gc_refs &gt; 0)
              gc-&gt;gc.gc_refs--;  // -1
      }
      return 0;
  }</p>
<p>/<em> Subtract internal references from gc_refs.  After this, gc_refs is &gt;= 0
   * for all objects in containers, and is GC_REACHABLE for all tracked gc
   * objects not in containers.  The ones with gc_refs &gt; 0 are directly
   * reachable from outside containers, and so can't be collected.
   </em>/
  static void
  subtract_refs(PyGC_Head <em>containers)
  {
      traverseproc traverse;
      PyGC_Head </em>gc = containers-&gt;gc.gc_next;
      // 遍历链表
      for (; gc != containers; gc=gc-&gt;gc.gc_next) {
          // 与特定的类型相关, 得到类型对应的traverse函数
          traverse = Py_TYPE(FROM_GC(gc))-&gt;tp_traverse;
          // 调用
          (void) traverse(FROM_GC(gc),
                         (visitproc)visit_decref, // 回调形式传入
                         NULL);
      }
  }
```</p>
<p>我们可以看看dictobject的traverse函数</p>
<p>```c
  static int
  dict_traverse(PyObject <em>op, visitproc visit, void </em>arg)
  {
      Py_ssize_t i = 0;
      PyObject <em>pk;
      PyObject </em>pv;</p>
<div class="monokai"><pre><span></span>  // 遍历所有键和值
  while (PyDict_Next(op, &amp;i, &amp;pk, &amp;pv)) {
      Py_VISIT(pk);
      Py_VISIT(pv);
  }
  return 0;
</pre></div>
<p>}
```</p>
<p>逻辑大概是: 遍历容器对象里面的所有对象, 通过<code>visit_decref</code>将这些对象的引用计数都-1,</p>
<p>最终, 遍历完链表之后, 整个可收集对象链表中所有container对象之间的循环引用都被去掉了</p>
<h4 id="4-di-si-bu-la-ji-biao-ji">4. 第四步: 垃圾标记</h4>
<p><code>move_unreachable</code>, 将可收集对象链表中, 根据有效引用计数 不等于0(root对象) 和 等于0(非root对象, 垃圾, 可回收), 一分为二</p>
<p>```c
 /<em> Move the unreachable objects from young to unreachable.  After this,
   * all objects in young have gc_refs = GC_REACHABLE, and all objects in
   * unreachable have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All tracked
   * gc objects not in young or unreachable still have gc_refs = GC_REACHABLE.
   * All objects in young after this are directly or indirectly reachable
   * from outside the original young; and all objects in unreachable are
   * not.
   </em>/
  static void
  move_unreachable(PyGC_Head <em>young, PyGC_Head </em>unreachable)
  {
      PyGC_Head *gc = young-&gt;gc.gc_next;</p>
<div class="monokai"><pre><span></span>  /* Invariants:  all objects "to the left" of us in young have gc_refs
   * = GC_REACHABLE, and are indeed reachable (directly or indirectly)
   * from outside the young list as it was at entry.  All other objects
   * from the original young "to the left" of us are in unreachable now,
   * and have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All objects to the
   * left of us in 'young' now have been scanned, and no objects here
   * or to the right have been scanned yet.
   */

  while (gc != young) {
      PyGC_Head *next;

      // 对于root object,
      if (gc-&gt;gc.gc_refs) {
          /* gc is definitely reachable from outside the
           * original 'young'.  Mark it as such, and traverse
           * its pointers to find any other objects that may
           * be directly reachable from it.  Note that the
           * call to tp_traverse may append objects to young,
           * so we have to wait until it returns to determine
           * the next object to visit.
           */
          PyObject *op = FROM_GC(gc);
          traverseproc traverse = Py_TYPE(op)-&gt;tp_traverse;
          assert(gc-&gt;gc.gc_refs &gt; 0);
          // 设置其gc-&gt;gc.gc_refs = GC_REACHABLE
          gc-&gt;gc.gc_refs = GC_REACHABLE;

          // 注意这里逻辑, visit_reachable, 意图是?
          (void) traverse(op,
                          (visitproc)visit_reachable,
                          (void *)young);
          next = gc-&gt;gc.gc_next;
          if (PyTuple_CheckExact(op)) {
              _PyTuple_MaybeUntrack(op);
          }
      }
      // 有效引用计数=0, 非root对象, 移动到unreachable链表中
      else {
          /* This *may* be unreachable.  To make progress,
           * assume it is.  gc isn't directly reachable from
           * any object we've already traversed, but may be
           * reachable from an object we haven't gotten to yet.
           * visit_reachable will eventually move gc back into
           * young if that's so, and we'll see it again.
           */
          next = gc-&gt;gc.gc_next;
          gc_list_move(gc, unreachable);
          gc-&gt;gc.gc_refs = GC_TENTATIVELY_UNREACHABLE;
      }
      gc = next;
  }
</pre></div>
<p>}
```</p>
<h4 id="5-di-wu-bu-jiang-cun-huo-dui-xiang-fang-ru-xia-yi-dai">5. 第五步: 将存活对象放入下一代</h4>
<p>```c
      /<em> Move reachable objects to next generation. </em>/
      if (young != old) {
          if (generation == NUM_GENERATIONS - 2) {
              long_lived_pending += gc_list_size(young);
          }
          gc_list_merge(young, old);
      }
      else {
          /<em> We only untrack dicts in full collections, to avoid quadratic
             dict build-up. See issue #14775. </em>/
          untrack_dicts(young);
          long_lived_pending = 0;
          long_lived_total = gc_list_size(young);
      }</p>
<p>```</p>
<h4 id="6-di-liu-bu-zhi-xing-hui-shou">6. 第六步: 执行回收</h4>
<p>```c
gcmoudle.c</p>
<p>static int
  gc_list_is_empty(PyGC_Head *list)
  {
      return (list-&gt;gc.gc_next == list);
  }</p>
<p>/<em> Break reference cycles by clearing the containers involved.  This is
   * tricky business as the lists can be changing and we don't know which
   * objects may be freed.  It is possible I screwed something up here.
   </em>/
  static void
  delete_garbage(PyGC_Head <em>collectable, PyGC_Head </em>old)
  {
      inquiry clear;</p>
<div class="monokai"><pre><span></span>  // 遍历
  while (!gc_list_is_empty(collectable)) {
      PyGC_Head *gc = collectable-&gt;gc.gc_next;
      // 得到对象
      PyObject *op = FROM_GC(gc);

      assert(IS_TENTATIVELY_UNREACHABLE(op));
      if (debug &amp; DEBUG_SAVEALL) {
          PyList_Append(garbage, op);
      }
      else {
          // 清引用
          if ((clear = Py_TYPE(op)-&gt;tp_clear) != NULL) {
              Py_INCREF(op);
              // 这个操作会调整container对象中每个引用所有对象的引用计数, 从而完成打破循环的最终目标
              clear(op);
              Py_DECREF(op);
          }
      }

      // 重新送回到reachable链表.
      // 原因: 在进行clear动作, 如果成功, 会把自己从垃圾收集机制维护的链表中摘除, 由于某些原因, 对象可能在clear的时候, 没有成功完成必要动作, 还不能被销毁, 所以放回去
      if (collectable-&gt;gc.gc_next == gc) {
          /* object is still alive, move it, it may die later */
          gc_list_move(gc, old);
          gc-&gt;gc.gc_refs = GC_REACHABLE;
      }
  }
</pre></div>
<p>}</p>
<p>=&gt; 来看下, list的clear</p>
<p>static int
list_clear(PyListObject <em>a)
{
    Py_ssize_t i;
    PyObject </em><em>item = a-&gt;ob_item;
    if (item != NULL) {
        /</em> Because XDECREF can recursively invoke operations on
           this list, we make it empty first. <em>/
        i = Py_SIZE(a);
        Py_SIZE(a) = 0;
        a-&gt;ob_item = NULL;
        a-&gt;allocated = 0;
        while (--i &gt;= 0) {
            // 减引用
            Py_XDECREF(item[i]);
        }
        PyMem_FREE(item);
    }
    /</em> Never fails; the return value can be ignored.
       Note that there is no guarantee that the list is actually empty
       at this point, because XDECREF may have populated it again! */
    return 0;
}</p>
<p>// e.g. 处理list3, 调用其list_clear, 减少list4的引用计数, list4.ob_refcnt=0, 引发对象销毁, 调用list4的list_dealloc</p>
<p>static void
list_dealloc(PyListObject *op)
{
    Py_ssize_t i;
    PyObject_GC_UnTrack(op);  //  从可收集对象链表中去除, 会影响到list4所引用所有对象的引用计数, =&gt; list3.refcnt=0, list3的销毁动作也被触发</p>
<div class="monokai"><pre><span></span>Py_TRASHCAN_SAFE_BEGIN(op)
if (op-&gt;ob_item != NULL) {
    /* Do it backwards, for Christian Tismer.
       There's a simple test case where somehow this reduces
       thrashing when a *very* large list is created and
       immediately deleted. */
    i = Py_SIZE(op);
    while (--i &gt;= 0) {
        Py_XDECREF(op-&gt;ob_item[i]);
    }
    PyMem_FREE(op-&gt;ob_item);
}
if (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op))
    free_list[numfree++] = op;
else
    Py_TYPE(op)-&gt;tp_free((PyObject *)op);
Py_TRASHCAN_SAFE_END(op)
</pre></div>
<p>}
```</p>
<h4 id="7-gcluo-ji">7. gc逻辑</h4>
<p><code>分配内存
-&gt; 发现超过阈值了
-&gt; 触发垃圾回收
-&gt; 将所有可收集对象链表放到一起
-&gt; 遍历, 计算有效引用计数
-&gt; 分成 有效引用计数=0 和 有效引用计数 &gt; 0 两个集合
-&gt; 大于0的, 放入到更老一代
-&gt; =0的, 执行回收
-&gt; 回收遍历容器内的各个元素, 减掉对应元素引用计数(破掉循环引用)
-&gt; 执行-1的逻辑, 若发现对象引用计数=0, 触发内存回收
-&gt; python底层内存管理机制回收内存</code></p>
<h2 id="fen-dai-hui-shou_2">分代回收</h2>
<p>分代收集: 以空间换时间</p>
<p>思想: 将系统中的所有内存块根据其存货的时间划分为不同的集合, 每个集合就成为一个"代", 垃圾收集的频率随着"代"的存活时间的增大而减小(活得越长的对象, 就越不可能是垃圾, 就应该减少去收集的频率)</p>
<p>Python中, 引入了分代收集, 总共三个"代". Python 中, 一个代就是一个链表, 所有属于同一"代"的内存块都链接在同一个链表中</p>
<h3 id="biao-tou-shu-ju-jie-gou">表头数据结构</h3>
<p>```c
gcmodule.c</p>
<p>struct gc_generation {
      PyGC_Head head;
      int threshold; /<em> collection threshold </em>/  // 阈值
      int count; /<em> count of allocations or collections of younger
                    generations </em>/    // 实时个数
  };
```</p>
<h3 id="san-ge-dai-de-ding-yi">三个代的定义</h3>
<p>```c
  #define NUM_GENERATIONS 3
  #define GEN_HEAD(n) (&amp;generations[n].head)</p>
<p>//  三代都放到这个数组中
  /<em> linked lists of container objects </em>/
  static struct gc_generation generations[NUM_GENERATIONS] = {
      /<em> PyGC_Head,                               threshold,      count </em>/
      {{{GEN_HEAD(0), GEN_HEAD(0), 0}},           700,            0},    //700个container, 超过立即触发垃圾回收机制
      {{{GEN_HEAD(1), GEN_HEAD(1), 0}},           10,             0},    // 10个
      {{{GEN_HEAD(2), GEN_HEAD(2), 0}},           10,             0},    // 10个
  };</p>
<p>PyGC_Head *_PyGC_generation0 = GEN_HEAD(0);
```</p>
<h3 id="chao-guo-yu-zhi-hong-fa-la-ji-hui-shou">超过阈值, 触发垃圾回收</h3>
<p>```c
 PyObject <em>
  _PyObject_GC_Malloc(size_t basicsize)
  {
      // 执行分配
      ....
      generations[0].count++; /</em> number of allocated GC objects */  //增加一个
      if (generations[0].count &gt; generations[0].threshold &amp;&amp; // 发现大于预支了
          enabled &amp;&amp;
          generations[0].threshold &amp;&amp;
          !collecting &amp;&amp;
          !PyErr_Occurred())
          {
              collecting = 1;
              collect_generations();  //  执行收集
              collecting = 0;
          }
      op = FROM_GC(g);
      return op;
  }</p>
<p>=&gt; collect_generations</p>
<p>static Py_ssize_t
  collect_generations(void)
  {
      int i;
      Py_ssize_t n = 0;</p>
<div class="monokai"><pre><span></span>  /* Find the oldest generation (highest numbered) where the count
   * exceeds the threshold.  Objects in the that generation and
   * generations younger than it will be collected. */

  // 从最老的一代, 开始回收
  for (i = NUM_GENERATIONS-1; i &gt;= 0; i--) {  // 遍历所有generation
      if (generations[i].count &gt; generations[i].threshold) {  // 如果超过了阈值
          /* Avoid quadratic performance degradation in number
             of tracked objects. See comments at the beginning
             of this file, and issue #4074.
          */
          if (i == NUM_GENERATIONS - 1
              &amp;&amp; long_lived_pending &lt; long_lived_total / 4)
              continue;
          n = collect(i); // 执行收集
          break;  // notice: break了
      }
  }
  return n;
</pre></div>
<p>}
```</p>
<h2 id="python-zhong-de-gcmo-kuai_1">Python 中的gc模块</h2>
<p>gc模块, 提供了观察和手动使用gc的接口</p>
<p>```python
import gc</p>
<p>gc.set_debug(gc.DEBUG_STATS | gc.DEBUG_LEAK)</p>
<p>gc.collect()
```</p>
<p>注意<code>__del__</code>给gc带来的影响</p>
    </section>

    <section id="copyright">
        <div class="copyright">
            版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" >Creative Commons BY-NC-ND 3.0</a>
        </div>

        <div class="donation">
            <center>
                <div style="width: 70%;">
                    <img src="/imgs/life/donation_w.png" style=""/>
                    <strong>
                        <div style="text-align:center;">
                            如果我的文章或项目对你有所帮助, 可以扫码进行小额捐赠<br>
                            如果有主机需求, 可点下方vultr进入注册, 带小尾巴:)<br>
                            如果要加广告位, 请邮件联系<br>
                        </ol>
                    </strong>
                </div>
            </center>

        </div>
    </section>


    <section id="neighbors">
        <div>
                        <a class="left" href="http://www.wklken.me/posts/2015/09/26/why-i-keep-blogging.html">
                            上一篇:  我为什么要写博客
                        </a>
                        <a class="right" href="http://www.wklken.me/posts/2015/11/08/summary-13-some-points.html">
                            下一篇: 这段时间的一些想法
                        </a>
        </div>
    </section>

    <section id="ad">
        <!-- <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> -->
        <!-- [> blog_ad_003 <] -->
        <!-- <ins class="adsbygoogle" -->
            <!-- style="display:block" -->
            <!-- data-ad-client="ca-pub-7635941258020589" -->
            <!-- data-ad-slot="7030416955" -->
            <!-- data-ad-format="auto"></ins> -->
        <!-- <script> -->
        <!-- (adsbygoogle = window.adsbygoogle || []).push({}); -->
        <!-- </script> -->

        <a href='http://www.vultr.com/?ref=6847203' target="_blank">
        <img src="/imgs/ads/vultr.png"> </img>
        </a>
    </section>



<section id="comments">
        <div class="comments">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                var disqus_identifier = "posts/2015/09/29/python-source-gc.html";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://wklken.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            </div>
</section>



</article>
        </section><!--end #main-->

            <footer class="row">
                <div class="large-12 columns">
                    <p>
                            Copyright © 2015 wklken <br>
                            Hosted on <a href="http://www.vultr.com/?ref=6954153-3B"> vultr </a>. Powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>. Social Icons by <a href="http://fortawesome.github.io/Font-Awesome/">Font-Awesome</a>.
                            <!-- Hosted on <a href="http://www.vultr.com/?ref=6847203"> vultr </a> Also <a href="https://www.digitalocean.com/?refcode=8ee73f2c47ce"> DigitalOcean </a>. Powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>. Social Icons by <a href="http://fortawesome.github.io/Font-Awesome/">Font-Awesome</a>. -->
                    </p>
                </div>
            </footer>

            </div>
        </div>

        <section id="extras" class="body">
        </section><!-- /#extras -->



<script src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="http://apps.bdimg.com/libs/jquery-scrollUp/2.1.0/jquery.scrollUp.min.js"></script>
<script src="http://apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
<script>
    $(function(){
        $.scrollUp({
              scrollText: '', // Text for element, can contain HTML
            });
    });
</script>


<script type="text/javascript">
  /* var Swiftype = window.Swiftype || {}; */
  /* Swiftype.searchSearchFields = { */
    /* "page": ["title^10", "body"] */
  /* }; */

  /* (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){ */
  /* (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t); */
  /* e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); */
  /* })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st'); */

  /* _st('install','v6K-_DamCeHvwX6z3o2F'); */
</script>



    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-42275748-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>




<div id="share">
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":["mshare","tsina","weixin","douban","meilishuo","mogujie","youdao","sdo","mail","twi","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"5","bdPos":"right","bdTop":"96.5"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
</div>



<script  src="http://www.wklken.me/theme/js/scroll-header.js" type="text/javascript"></script>




</body>
</html>